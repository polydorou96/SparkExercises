from pyspark.sql import Window, DataFrame
from pyspark.sql.functions import col, row_number, when, count, sum


def count_number_of_applications(applications: DataFrame) -> int:
    return applications.count()


def get_average_profit(applications: DataFrame, loans: DataFrame) -> float:
    approved_applications = applications.filter(col('status') == 'approved')
    approved_applications_and_loans = approved_applications.join(loans, on="loan_id", how="inner")

    sum_of_profit = approved_applications_and_loans.select(sum('commission'))

    average_of_profit = sum_of_profit.collect()[0][0] / approved_applications.count()
    return average_of_profit


def get_popular_marketing_sources(applications: DataFrame, loans: DataFrame,
                                  marketing_sources: DataFrame) -> DataFrame:
    approved_applications = applications.filter(col('status') == 'approved')

    # Join approved applications with loans and marketing source dfs
    approved_applications_and_loans = approved_applications.join(loans, on="loan_id", how="inner")
    approved_applications_and_loans_and_sources = (approved_applications_and_loans
                                                   .join(marketing_sources, on="source_id", how="inner"))

    # Join the dataframes and group by loan name and source name to get the number of applications
    applications_per_loan_and_source = (approved_applications_and_loans_and_sources.groupBy("loan_name", "source_name")
                                        .agg(count("app_id").alias("number_of_applications")))

    # Partition by loan name to get the most applications per loan name in descending order
    window_spec = (Window.partitionBy("loan_name")
                   .orderBy(applications_per_loan_and_source["number_of_applications"].desc()))

    # Get ranked sources according to number of applications
    ranked_sources = applications_per_loan_and_source.withColumn("ranked_source_name", row_number().over(window_spec))

    # Get the top 2 sources for each loan type
    first_most_popular_source = (ranked_sources.filter(ranked_sources["ranked_source_name"] == 1)
                                 .select("loan_name", "source_name")
                                 .withColumnRenamed("source_name", "Most popular"))
    second_most_popular_source = (ranked_sources.filter(ranked_sources["ranked_source_name"] == 2)
                                  .select("loan_name", "source_name")
                                  .withColumnRenamed("source_name", "Second most popular"))

    top_two_popular_sources = (first_most_popular_source.join(second_most_popular_source, on="loan_name",
                                                              how="inner").orderBy("loan_name")
                               .withColumnRenamed("loan_name", "Loan"))
    return top_two_popular_sources


def get_profit_percentage_from_each_marketing_source(applications: DataFrame, loans: DataFrame,
                                                     marketing_sources: DataFrame) -> DataFrame:
    approved_applications = applications.filter(col('status') == 'approved')

    # Join approved applications with loans and marketing source dfs
    approved_applications_and_loans = approved_applications.join(loans, on="loan_id", how="inner")
    approved_applications_and_loans_and_sources = approved_applications_and_loans.join(marketing_sources,
                                                                                       on="source_id",
                                                                                       how="inner")

    # Get overall profit generated by each marketing source on a given day, include daily target in the group by
    # statement as we are expecting each source to have the same daily target each day
    daily_profit = approved_applications_and_loans_and_sources.groupBy("date", "source_name", "daily_target").agg(
        sum(col("commission")).alias("daily_profit")
    )

    # Get the percentage of the daily target
    daily_target_percentage = (daily_profit.withColumn(
        "Daily Target %",
        when(col("daily_target") > 0, (col("daily_profit") / col("daily_target")) * 100).otherwise(0)
    ).drop("daily_target").orderBy("date", "source_name")
                               .withColumnRenamed("date", "Date")
                               .withColumnRenamed("source_name", "Source")
                               .withColumnRenamed("daily_profit", "Profit"))

    return daily_target_percentage
